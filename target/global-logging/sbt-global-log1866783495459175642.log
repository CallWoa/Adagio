[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (D:\gradProj\Adagio\target\scala-2.13\zinc\inc_compile_2.13.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed 2024-5-3 12:27:03[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///d%3A/gradProj/Adagio/src/main/scala/TensorCore/Top.scala","languageId":"scala","version":1,"text":"package TensorCore\r\n\r\nimport chisel3._\r\nimport chisel3.util._\r\n\r\n//class RegFile(width: Int, num: Int) {\r\n//  val rf = Mem(num, UInt(width.W))\r\n//  def read(addr: UInt): UInt = Mux(addr === 0.U, 0.U, rf(addr))\r\n//  def write(addr: UInt, data: UInt) = {\r\n//    rf(addr) := data(width - 1, 0)\r\n//  }\r\n//}\r\n\r\nclass tcSrc (bit: Int) extends Bundle {\r\n  val ot0_tg0_matrix_a = Input(UInt(bit.W))\r\n  val ot0_tg0_matrix_b = Input(UInt(bit.W))\r\n  val ot0_tg0_matrix_c = Input(UInt(bit.W))\r\n\r\n  val ot0_tg4_matrix_a = Input(UInt(bit.W))\r\n  val ot0_tg4_matrix_b = Input(UInt(bit.W))\r\n  val ot0_tg4_matrix_c = Input(UInt(bit.W))\r\n\r\n  val ot1_tg0_matrix_a = Input(UInt(bit.W))\r\n  val ot1_tg0_matrix_b = Input(UInt(bit.W))\r\n  val ot1_tg0_matrix_c = Input(UInt(bit.W))\r\n\r\n  val ot1_tg4_matrix_a = Input(UInt(bit.W))\r\n  val ot1_tg4_matrix_b = Input(UInt(bit.W))\r\n  val ot1_tg4_matrix_c = Input(UInt(bit.W))\r\n}\r\n\r\nclass topIn (bit: Int) extends Bundle {\r\n  val tc0 = new tcSrc(bit)\r\n  val tc1 = new tcSrc(bit)\r\n  val ctrl = new octetCtrl()\r\n}\r\nclass topOut (bit: Int) extends Bundle {\r\n  val tc0 = new tensorCoreOut(bit)\r\n  val tc1 = new tensorCoreOut(bit)\r\n}\r\n\r\nclass Top (bit: Int) extends Module {\r\n  val io = IO(new Bundle {\r\n    val in = Flipped(Decoupled(new topIn(bit)))\r\n    val out = Decoupled(new topOut(bit))\r\n  })\r\n\r\n  val rm = io.in.bits.ctrl.roundingMode\r\n  val mixPc = io.in.bits.ctrl.mixPcMode\r\n  val matBSel = io.in.bits.ctrl.matBSel\r\n\r\n  val tc0 = io.in.bits.tc0\r\n  val tc1 = io.in.bits.tc1\r\n  val tensorCore = VecInit(tc0, tc1)\r\n\r\n  val ot0_matrix_d = Wire(Vec(2, Vec(2, new Matrix(bit))))\r\n  val ot1_matrix_d = Wire(Vec(2, Vec(2, new Matrix(bit))))\r\n  val tc_valid = Wire(Vec(2, Bool()))\r\n  val tc_ready = Wire(Vec(2, Bool()))\r\n  for(i <- 0 to 1){\r\n    val ot0_tg0_matrix_a = Matrix.fromUInt(tensorCore(i).ot0_tg0_matrix_a, true)\r\n    val ot0_tg0_matrix_b = Matrix.fromUInt(tensorCore(i).ot0_tg0_matrix_b, false)\r\n    val ot0_tg0_matrix_c = Matrix.fromUInt(tensorCore(i).ot0_tg0_matrix_c, true)\r\n\r\n    val ot0_tg4_matrix_a = Matrix.fromUInt(tensorCore(i).ot0_tg4_matrix_a, true)\r\n    val ot0_tg4_matrix_b = Matrix.fromUInt(tensorCore(i).ot0_tg4_matrix_b, false)\r\n    val ot0_tg4_matrix_c = Matrix.fromUInt(tensorCore(i).ot0_tg4_matrix_c, true)\r\n\r\n    val ot1_tg0_matrix_a = Matrix.fromUInt(tensorCore(i).ot1_tg0_matrix_a, true)\r\n    val ot1_tg0_matrix_b = Matrix.fromUInt(tensorCore(i).ot1_tg0_matrix_b, false)\r\n    val ot1_tg0_matrix_c = Matrix.fromUInt(tensorCore(i).ot1_tg0_matrix_c, true)\r\n\r\n    val ot1_tg4_matrix_a = Matrix.fromUInt(tensorCore(i).ot1_tg4_matrix_a, true)\r\n    val ot1_tg4_matrix_b = Matrix.fromUInt(tensorCore(i).ot1_tg4_matrix_b, false)\r\n    val ot1_tg4_matrix_c = Matrix.fromUInt(tensorCore(i).ot1_tg4_matrix_c, true)\r\n\r\n    val tc = TensorCore(bit,\r\n      ot0_tg0_matrix_a, ot0_tg0_matrix_b, ot0_tg0_matrix_c,\r\n      ot0_tg4_matrix_a, ot0_tg4_matrix_b, ot0_tg4_matrix_c,\r\n      ot1_tg0_matrix_a, ot1_tg0_matrix_b, ot1_tg0_matrix_c,\r\n      ot1_tg4_matrix_a, ot1_tg4_matrix_b, ot1_tg4_matrix_c,\r\n      rm, mixPc, matBSel, io.in.valid, io.out.ready)\r\n    ot0_matrix_d(i) := VecInit(tc._1.threadgroup0.matrix_d, tc._1.threadgroup4.matrix_d)\r\n    ot1_matrix_d(i) := VecInit(tc._2.threadgroup0.matrix_d, tc._2.threadgroup4.matrix_d)\r\n    tc_valid(i) := tc._3\r\n    tc_ready(i) := tc._4\r\n  }\r\n\r\n  io.in.ready := tc_ready.reduce((_&&_))\r\n  io.out.valid := tc_valid.reduce(_&&_)\r\n  io.out.bits.tc0.octet0.threadgroup0.matrix_d := ot0_matrix_d(0)(0)\r\n  io.out.bits.tc0.octet0.threadgroup4.matrix_d := ot0_matrix_d(0)(1)\r\n  io.out.bits.tc1.octet0.threadgroup0.matrix_d := ot0_matrix_d(1)(0)\r\n  io.out.bits.tc1.octet0.threadgroup4.matrix_d := ot0_matrix_d(1)(1)\r\n\r\n  io.out.bits.tc0.octet1.threadgroup0.matrix_d := ot1_matrix_d(0)(0)\r\n  io.out.bits.tc0.octet1.threadgroup4.matrix_d := ot1_matrix_d(0)(1)\r\n  io.out.bits.tc1.octet1.threadgroup0.matrix_d := ot1_matrix_d(1)(0)\r\n  io.out.bits.tc1.octet1.threadgroup4.matrix_d := ot1_matrix_d(1)(1)\r\n}\r\n\r\n\r\nobject Top extends App {\r\n  emitVerilog(new Top(matsize), Array(\"--target-dir\", \"generated\"))\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///d%3A/gradProj/Adagio/src/main/scala/TensorCore/Top.scala"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///d%3A/gradProj/Adagio/src/main/scala/System/System.scala","languageId":"scala","version":1,"text":"package System\r\n\r\nimport TensorCore._\r\nimport chisel3._\r\nimport chisel3.util._\r\nimport chisel3.util.experimental.{loadMemoryFromFile,loadMemoryFromFileInline}\r\n\r\nclass RegFile() {\r\n  val rf = Mem(NRReg, UInt(XLEN.W))\r\n//  loadMemoryFromFileInline(rf, \"../../../test/modelsim/src/matrix_src.txt\")\r\n  def read(addr: UInt): UInt = Mux(addr === 0.U, 0.U, rf(addr))\r\n  def write(addr: UInt, data: UInt) = {\r\n    rf(addr) := data(XLEN - 1, 0)\r\n  }\r\n}\r\n\r\n\r\nclass tensor_m16n16k16() {\r\n  val rf = new RegFile\r\n  def coordTrans (x: Int, y: Int, matrixTag: Char, mixPc: Boolean): Int = {\r\n    val index = matrixTag match {\r\n      case 'A' => x * 4 + y / 4\r\n      case 'B' => x * 4 + y / 4 + 64\r\n      case 'C' => if(mixPc) x * 8 + y / 2 + 128 else x * 4 + y /4 + 128\r\n    }\r\n    index\r\n  }\r\n\r\n  def readMatrix(tgTag: Int, set: Int, step: Int, matrixTag: Char, mixPc: Boolean): UInt = {\r\n    def MAX_STEP: Int = if(mixPc) 4 else 2\r\n    val rows = matrixTag match {\r\n      case 'A' | 'C' => if(mixPc) 2 else 4\r\n      case 'B' => 4\r\n    }\r\n    val cols = matrixTag match {\r\n      case 'A' | 'B' => 1\r\n      case 'C' => if(mixPc) 2 else 1\r\n    }\r\n    val row_lo = matrixTag match {\r\n      case 'A' | 'C' => tgTag match {\r\n        case 0 | 2 => 0\r\n        case 4 | 6 => 4\r\n        case 1 | 3 => 8\r\n        case 5 | 7 => 12\r\n      }\r\n      case 'B' => set match {\r\n        case 1 => 0\r\n        case 2 => 4\r\n        case 3 => 8\r\n        case 4 => 12\r\n      }\r\n    }\r\n    val col_lo = matrixTag match {\r\n      case 'A' => set match {\r\n        case 1 => 0\r\n        case 2 => 4\r\n        case 3 => 8\r\n        case 4 => 12\r\n      }\r\n      case 'B' => tgTag match {\r\n        case 0 | 1 => 0\r\n        case 4 | 5 => 4\r\n        case 2 | 3 => 8\r\n        case 6 | 7 => 12\r\n      }\r\n      case 'C' => tgTag match {\r\n        case 0 | 1 | 4 | 5 => 0\r\n        case 2 | 6 | 3 | 7 => 8\r\n      }\r\n    }\r\n\r\n    val nelem = rows * cols\r\n    val tile_v = Wire(Vec(nelem, UInt(XLEN.W)))\r\n    for(i <- 0 until rows){\r\n      for(j <- 0 until cols){\r\n        val x = matrixTag match {\r\n          case 'A' | 'C' => if (mixPc) row_lo + (step % 2) * 2 + i else row_lo + i\r\n          case 'B' => row_lo + i\r\n        }\r\n        val y_bias = if (step < (MAX_STEP / 2)) 0 else 4\r\n        val y = matrixTag match {\r\n          case 'A' | 'B' => col_lo + j * 4\r\n          case 'C' => col_lo + j * 2 + y_bias\r\n        }\r\n        val n = nelem - 1 - (i * cols + j)\r\n        tile_v(n) := rf.read(coordTrans(x, y, matrixTag, mixPc).U)\r\n      }\r\n    }\r\n    tile_v.asUInt\r\n  }\r\n\r\n  def writeMatrix (tgTag: Int, step: Int, mixPc: Boolean, data: UInt):Unit = {\r\n    def MAX_STEP: Int = if(mixPc) 4 else 2\r\n    val rows = if(mixPc) 2 else 4\r\n    val cols = if(mixPc) 2 else 1\r\n    val nelem = rows * cols\r\n    val data_v = Wire(Vec(nelem, UInt(XLEN.W)))\r\n    for(i <- 0 until nelem){\r\n      val lsb = i * XLEN\r\n      val msb = i * XLEN + (XLEN - 1)\r\n      data_v(i) := data(msb, lsb)\r\n    }\r\n    val row_lo = tgTag match {\r\n      case 0 | 2 => 0\r\n      case 4 | 6 => 4\r\n      case 1 | 3 => 8\r\n      case 5 | 7 => 12\r\n    }\r\n    val col_lo = tgTag match {\r\n      case 0 | 1 | 4 | 5 => 0\r\n      case 2 | 6 | 3 | 7 => 8\r\n    }\r\n\r\n    for (i <- 0 until rows) {\r\n      for (j <- 0 until cols) {\r\n        val x = if (mixPc) row_lo + (step % 2) * 2 + i else row_lo + i\r\n        val y_bias = if (step < (MAX_STEP / 2)) 0 else 4\r\n        val y = col_lo + j * 2 + y_bias\r\n        val addr = coordTrans(x, y, 'C', mixPc)\r\n        val n = nelem - 1 - (i * cols + j)\r\n        rf.write(addr.U, data_v(n))\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n//class sysIn() extends Bundle {\r\n//}\r\n//class sysOut (bit: Int) extends Bundle {\r\n//\r\n//}\r\n\r\nclass System () extends Module {\r\n    val io = IO(new Bundle {\r\n      val mixPc = Input(Bool())\r\n      val exec_en = Input(Bool())\r\n      val out = Decoupled(new topOut(matsize))\r\n    })\r\n  def MAX_SET: Int = 4\r\n\r\n  val mixPc = io.mixPc\r\n  val exec_en = io.exec_en\r\n\r\n  val MAX_STEP = Reg(UInt(2.W))\r\n  when(mixPc){\r\n    MAX_STEP := 3.U\r\n  } .otherwise{\r\n    MAX_STEP := 1.U\r\n  }\r\n  val set = Reg(UInt(2.W))\r\n  val step = Reg(UInt(2.W))\r\n  val out_set = Reg(UInt(2.W))\r\n  val out_step = Reg(UInt(2.W))\r\n  var set_int = 0\r\n  var step_int = 0\r\n  var out_step_int = 0\r\n  var mixPc_boolean = true\r\n  switch(set) {\r\n    is(0.U) {\r\n      set_int = 1\r\n    }\r\n    is(1.U) {\r\n      set_int = 2\r\n    }\r\n    is(2.U) {\r\n      set_int = 3\r\n    }\r\n    is(3.U) {\r\n      set_int = 4\r\n    }\r\n  }\r\n  switch(step) {\r\n    is(0.U) {\r\n      step_int = 0\r\n    }\r\n    is(1.U) {\r\n      step_int = 1\r\n    }\r\n    is(2.U) {\r\n      step_int = 2\r\n    }\r\n    is(3.U) {\r\n      step_int = 3\r\n    }\r\n  }\r\n  switch(mixPc) {\r\n    is(true.B) {\r\n      mixPc_boolean = true\r\n    }\r\n    is(false.B) {\r\n      mixPc_boolean = false\r\n    }\r\n  }\r\n  switch(out_step) {\r\n    is(0.U) {\r\n      out_step_int = 0\r\n    }\r\n    is(1.U) {\r\n      out_step_int = 1\r\n    }\r\n    is(2.U) {\r\n      out_step_int = 2\r\n    }\r\n    is(3.U) {\r\n      out_step_int = 3\r\n    }\r\n  }\r\n\r\n  val matrix_a = Reg(Vec(8, UInt(matsize.W)))\r\n  val matrix_b = Reg(Vec(8, UInt(matsize.W)))\r\n  val matrix_c = Reg(Vec(8, UInt(matsize.W)))\r\n  val matBsel = Reg(Bool())\r\n\r\n  val top = Module(new Top(matsize))\r\n  top.io.out.ready := io.out.ready\r\n  top.io.in.bits.ctrl.roundingMode := 0.U(3.W)\r\n  top.io.in.bits.ctrl.mixPcMode := mixPc\r\n  top.io.in.bits.ctrl.matBSel := matBsel\r\n\r\n  top.io.in.bits.tc0.ot0_tg0_matrix_a := matrix_a(0)\r\n  top.io.in.bits.tc0.ot0_tg0_matrix_b := matrix_b(0)\r\n  top.io.in.bits.tc0.ot0_tg0_matrix_c := matrix_c(0)\r\n\r\n  top.io.in.bits.tc0.ot0_tg4_matrix_a := matrix_a(4) \r\n  top.io.in.bits.tc0.ot0_tg4_matrix_b := matrix_b(4)\r\n  top.io.in.bits.tc0.ot0_tg4_matrix_c := matrix_c(4)\r\n\r\n  top.io.in.bits.tc0.ot1_tg0_matrix_a := matrix_a(1)\r\n  top.io.in.bits.tc0.ot1_tg0_matrix_b := matrix_b(1)\r\n  top.io.in.bits.tc0.ot1_tg0_matrix_c := matrix_c(1)\r\n\r\n  top.io.in.bits.tc0.ot1_tg4_matrix_a := matrix_a(5)\r\n  top.io.in.bits.tc0.ot1_tg4_matrix_b := matrix_b(5)\r\n  top.io.in.bits.tc0.ot1_tg4_matrix_c := matrix_c(5)\r\n\r\n  top.io.in.bits.tc1.ot0_tg0_matrix_a := matrix_a(2)\r\n  top.io.in.bits.tc1.ot0_tg0_matrix_b := matrix_b(2)\r\n  top.io.in.bits.tc1.ot0_tg0_matrix_c := matrix_c(2)\r\n\r\n  top.io.in.bits.tc1.ot0_tg4_matrix_a := matrix_a(6)\r\n  top.io.in.bits.tc1.ot0_tg4_matrix_b := matrix_b(6)\r\n  top.io.in.bits.tc1.ot0_tg4_matrix_c := matrix_c(6)\r\n\r\n  top.io.in.bits.tc1.ot1_tg0_matrix_a := matrix_a(3)\r\n  top.io.in.bits.tc1.ot1_tg0_matrix_b := matrix_b(3)\r\n  top.io.in.bits.tc1.ot1_tg0_matrix_c := matrix_c(3)\r\n\r\n  top.io.in.bits.tc1.ot1_tg4_matrix_a := matrix_a(7)\r\n  top.io.in.bits.tc1.ot1_tg4_matrix_b := matrix_b(7)\r\n  top.io.in.bits.tc1.ot1_tg4_matrix_c := matrix_c(7)\r\n\r\n  io.out.bits.tc0.octet0.threadgroup0.matrix_d.data := top.io.out.bits.tc0.octet0.threadgroup0.matrix_d.data\r\n  io.out.bits.tc0.octet0.threadgroup4.matrix_d.data := top.io.out.bits.tc0.octet0.threadgroup4.matrix_d.data\r\n  io.out.bits.tc0.octet1.threadgroup0.matrix_d.data := top.io.out.bits.tc0.octet1.threadgroup0.matrix_d.data\r\n  io.out.bits.tc0.octet1.threadgroup4.matrix_d.data := top.io.out.bits.tc0.octet1.threadgroup4.matrix_d.data\r\n  io.out.bits.tc1.octet0.threadgroup0.matrix_d.data := top.io.out.bits.tc1.octet0.threadgroup0.matrix_d.data\r\n  io.out.bits.tc1.octet0.threadgroup4.matrix_d.data := top.io.out.bits.tc1.octet0.threadgroup4.matrix_d.data\r\n  io.out.bits.tc1.octet1.threadgroup0.matrix_d.data := top.io.out.bits.tc1.octet1.threadgroup0.matrix_d.data\r\n  io.out.bits.tc1.octet1.threadgroup4.matrix_d.data := top.io.out.bits.tc1.octet1.threadgroup4.matrix_d.data\r\n\r\n  val tensor = new tensor_m16n16k16\r\n  val in_valid = (out_set === set) || ((out_set === (set - 1.U)) && (out_step > step)) && exec_en\r\n  top.io.in.valid := RegNext(in_valid)\r\n  val handshaked = in_valid && top.io.in.ready\r\n\r\n  when(handshaked){\r\n    when(mixPc){\r\n      matBsel := step > 1.U\r\n    }.otherwise{\r\n      matBsel := step > 0.U\r\n    }\r\n\r\n    for(i <- 0 until 8){\r\n      val a = tensor.readMatrix(i, set_int, step_int, 'A', mixPc_boolean)\r\n      matrix_a(i) := Mux(mixPc, Cat(a, 0.U((matsize / 2).W)), a)\r\n      matrix_b(i) := tensor.readMatrix(i, set_int, step_int, 'B', mixPc_boolean)\r\n      matrix_c(i) := tensor.readMatrix(i, set_int, step_int, 'C', mixPc_boolean)\r\n    }\r\n\r\n    when(step === MAX_STEP) {\r\n      set := set + 1.U\r\n    }\r\n    step := step + 1.U\r\n  }\r\n\r\n  when (top.io.out.valid && top.io.out.ready){\r\n    tensor.writeMatrix(0, out_step_int, mixPc_boolean, top.io.out.bits.tc0.octet0.threadgroup0.matrix_d.data)\r\n    tensor.writeMatrix(4, out_step_int, mixPc_boolean, top.io.out.bits.tc0.octet0.threadgroup4.matrix_d.data)\r\n    tensor.writeMatrix(1, out_step_int, mixPc_boolean, top.io.out.bits.tc0.octet1.threadgroup0.matrix_d.data)\r\n    tensor.writeMatrix(5, out_step_int, mixPc_boolean, top.io.out.bits.tc0.octet1.threadgroup4.matrix_d.data)\r\n    tensor.writeMatrix(2, out_step_int, mixPc_boolean, top.io.out.bits.tc1.octet0.threadgroup0.matrix_d.data)\r\n    tensor.writeMatrix(6, out_step_int, mixPc_boolean, top.io.out.bits.tc1.octet0.threadgroup4.matrix_d.data)\r\n    tensor.writeMatrix(3, out_step_int, mixPc_boolean, top.io.out.bits.tc1.octet1.threadgroup0.matrix_d.data)\r\n    tensor.writeMatrix(7, out_step_int, mixPc_boolean, top.io.out.bits.tc1.octet1.threadgroup4.matrix_d.data)\r\n\r\n    when(out_step === MAX_STEP) {\r\n      out_set := out_set + 1.U\r\n    }\r\n    out_step := out_step + 1.U\r\n  }\r\n  when(top.io.out.valid && top.io.out.ready && (out_step === MAX_STEP) &&(out_set === (MAX_SET - 1).U)){\r\n    io.out.valid := true.B\r\n  }.otherwise{\r\n    io.out.valid := false.B\r\n  }\r\n\r\n}\r\n\r\n\r\nobject System extends App {\r\n  emitVerilog(new System(), Array(\"--target-dir\", \"generated\"))\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mForcing garbage collection...[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: $/setTraceNotification: JsonRpcNotificationMessage(2.0, $/setTraceNotification, {"value":"off"})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///d%3A/gradProj/Adagio/src/main/scala/System/System.scala"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled request received: shutdown: JsonRpcRequestMessage(2.0, â™¨1, shutdown, null})[0m
